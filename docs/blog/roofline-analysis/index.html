<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Md Saidul Hoque Anik">
<meta name="description" content="A blog post explaining the Roofline model by starting from basic processor–memory interaction to motivate the X-axis (arithmetic intensity) and Y-axis (performance), then showing how optimizations move a kernel right or up on the plot, and finally introducing the memory-bandwidth and compute roofs that bound achievable performance.">

<title>Understanding the Roofline Model without the Roof (First) – Md Saidul Hoque Anik</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-b758ccaa5987ceb1b75504551e579abf.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-69585d0cb7eb4d91e1e9639bd63741e7.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-435edb4a015d21cda02749244a61383a.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../../site_libs/bootstrap/bootstrap-69585d0cb7eb4d91e1e9639bd63741e7.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<link href="https://cdn.jsdelivr.net/npm/charter-webfont@4.1.0/charter.min.css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400..700;1,400..700&amp;family=Merriweather:ital,opsz,wght@0,18..144,300..900;1,18..144,300..900&amp;family=Open+Sans:ital,wght@0,300..800;1,300..800&amp;display=swap" rel="stylesheet">
<link href="https://fonts.cdnfonts.com/css/palatino" rel="stylesheet">
<script src="../../script.js"></script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Md Saidul Hoque Anik</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../research"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../news"> 
<span class="menu-text">News</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../teaching"> 
<span class="menu-text">Teaching</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-more" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">More</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-more">    
        <li>
    <a class="dropdown-item" href="../../leetgpu">
 <span class="dropdown-text">LeetGPU</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../leadership/">
 <span class="dropdown-text">Leadership</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../software">
 <span class="dropdown-text">Software</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../news/#category=Publication">
 <span class="dropdown-text">Publications</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../blog">
 <span class="dropdown-text">Blog</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#preface" id="toc-preface" class="nav-link active" data-scroll-target="#preface">Preface</a></li>
  <li><a href="#the-plot" id="toc-the-plot" class="nav-link" data-scroll-target="#the-plot">The Plot</a>
  <ul class="collapse">
  <li><a href="#improvement-strategies" id="toc-improvement-strategies" class="nav-link" data-scroll-target="#improvement-strategies">Improvement Strategies</a></li>
  </ul></li>
  <li><a href="#the-rooflines" id="toc-the-rooflines" class="nav-link" data-scroll-target="#the-rooflines">The Rooflines</a>
  <ul class="collapse">
  <li><a href="#memory-roof" id="toc-memory-roof" class="nav-link" data-scroll-target="#memory-roof">Memory Roof</a></li>
  <li><a href="#compute-roof" id="toc-compute-roof" class="nav-link" data-scroll-target="#compute-roof">Compute Roof</a></li>
  <li><a href="#the-roof-equation" id="toc-the-roof-equation" class="nav-link" data-scroll-target="#the-roof-equation">The Roof Equation</a></li>
  </ul></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">Summary</a>
  <ul class="collapse">
  <li><a href="#going-right-higher-arithmetic-intensity-lower-bytes-per-op" id="toc-going-right-higher-arithmetic-intensity-lower-bytes-per-op" class="nav-link" data-scroll-target="#going-right-higher-arithmetic-intensity-lower-bytes-per-op">Going Right (higher arithmetic intensity, lower bytes per OP)</a></li>
  <li><a href="#going-up-higher-ops-better-compute-utilization" id="toc-going-up-higher-ops-better-compute-utilization" class="nav-link" data-scroll-target="#going-up-higher-ops-better-compute-utilization">Going up (higher OP/s, better compute utilization)</a></li>
  <li><a href="#dual-impact-techniques-move-both-right-and-up" id="toc-dual-impact-techniques-move-both-right-and-up" class="nav-link" data-scroll-target="#dual-impact-techniques-move-both-right-and-up">Dual-impact techniques (move both right <strong>and</strong> up)</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Understanding the Roofline Model without the Roof (First)</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Hands-on</div>
  </div>
  </div>

<div>
  <div class="description">
    A blog post explaining the Roofline model by starting from basic processor–memory interaction to motivate the X-axis (arithmetic intensity) and Y-axis (performance), then showing how optimizations move a kernel right or up on the plot, and finally introducing the memory-bandwidth and compute roofs that bound achievable performance.
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Md Saidul Hoque Anik </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 2026</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="preface" class="level2">
<h2 class="anchored" data-anchor-id="preface">Preface</h2>
<p>A typical computing system consists of two main components: <strong>memory</strong> and a <strong>processor</strong>, as illustrated below. During program execution, data is fetched from memory into the processor, where computations are performed.</p>
<p>The rate at which data can be transferred between memory and the processor over the bus is measured in <strong>bytes per second (Byte/s)</strong>. <strong>This is a property of the memory subsystem.</strong></p>
<p>The rate at which the processor can execute operations is measured in <strong>operations per second (op/s)</strong>. <strong>This is a property of the processor (CPU or GPU).</strong></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/paste-20.png" class="img-fluid figure-img"></p>
<figcaption>A typical computing system</figcaption>
</figure>
</div>
<p>As a concrete example, consider a <strong>vector addition</strong>. For each element, we load two floating-point values from memory, add them together (the actual computation), and store the result back to memory. We will omit the store for now, since writes may not immediately consume memory bandwidth (they may first go to cache and be written back later).</p>
<p>In this operation, we load two floats: 4 + 4 = 8 bytes total, and perform a single arithmetic operation.</p>
<p>We therefore say that this program has an <strong>arithmetic intensity (AI)</strong> of:</p>
<div style="text-align: center">
<p>AI = 1 op / 8 bytes = 1/8 op/byte</p>
</div>
<p>In other words, for every byte fetched from memory, the program performs 1/8 of an operation. This metric captures how effectively a program uses the data it moves. <strong>Arithmetic intensity is a property of the program (or its implementation/kernel).</strong></p>
<p>A different performance metric describes how fast the CPU or GPU is actually executing these operations, measured in <strong>op/s</strong>. This is commonly referred to as <strong>computational performance</strong> or <strong>throughput</strong>.</p>
<blockquote class="blockquote">
<p><strong>Arithmetic Intensity (AI)</strong> = op/byte<br>
How many operations are performed per byte of data moved. Also called <strong>Operational Intensity (OI)</strong>.</p>
<p><strong>Performance</strong> = op/s<br>
How fast the processor is executing operations. Also called <strong>throughput</strong> (when the pipeline is full and steady) .</p>
<p><strong>Note:</strong> Operations are often referred to as <strong>FLOPs</strong> (floating-point operations), since performance analysis usually focuses on floating-point workloads. For simplicity, we will use the term <strong>op</strong> throughout this article.</p>
</blockquote>
</section>
<section id="the-plot" class="level2">
<h2 class="anchored" data-anchor-id="the-plot">The Plot</h2>
<p>We can visualize these two metrics on an X–Y plot.</p>
<ul>
<li>The <strong>X-axis</strong> is <strong>op/byte</strong>, which measures how well we utilize the data we fetch.</li>
<li>The <strong>Y-axis</strong> is <strong>op/s</strong>, which measures how fast we are executing operations.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/paste-14.png" class="img-fluid figure-img" width="512"></p>
<figcaption>The Roofline plot without the roofs!</figcaption>
</figure>
</div>
<p>Moving <strong>to the right</strong> means we are extracting more work from each byte of data.</p>
<p>Moving <strong>upward</strong> means we are executing more operations per second.</p>
<p>In practice, many optimizations improve both metrics at once, causing the point to move <strong>diagonally up and to the right</strong>.</p>
<section id="improvement-strategies" class="level3">
<h3 class="anchored" data-anchor-id="improvement-strategies">Improvement Strategies</h3>
<p>Let us first focus on a single point in this plot: the blue point at <strong>(1, 1)</strong>.</p>
<p>This point tells us that:</p>
<ul>
<li>The implementation performs <strong>1 operation per byte</strong> of data fetched (X coordinate).</li>
<li>The implementation runs at <strong>1 op/s</strong> (Y coordinate).</li>
</ul>
<p>By itself, this does not say whether the implementation is <em>good</em> or <em>bad</em>. However, following the theme of this article - <strong>memory vs.&nbsp;processor limitations</strong>, there are two orthogonal ways to improve performance.</p>
<hr>
<section id="increase-arithmetic-intensity-move-right" class="level4">
<h4 class="anchored" data-anchor-id="increase-arithmetic-intensity-move-right">1. Increase arithmetic intensity (move right)</h4>
<p>We can try to <strong>do more work per byte</strong>, i.e., increase <strong>op/byte</strong>, which moves the point <strong>horizontally to the right</strong>.</p>
<ul>
<li>This corresponds to moving from the blue point <strong>(1, 1)</strong> to the red point <strong>(2, 1)</strong>.</li>
</ul>
<p>How can we do more work with the same data? How about by reducing memory wastage?</p>
<p>A common example comes from <strong>matrix multiplication</strong>. Suppose matrix <strong>B</strong> is stored in row-major order, but the algorithm accesses it column-wise. Each load brings an entire cache line, yet only one element is used before the rest are evicted.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/paste-15.png" class="img-fluid figure-img" width="629"></p>
<figcaption>Accessing an element of each row means we will invalidate cache line every single time</figcaption>
</figure>
</div>
<p>If we instead use a <strong>transposed B matrix</strong>, accesses become contiguous in memory. This improves cache reuse and allows us to perform more operations with the same bytes fetched.</p>
<p>As a result, <strong>arithmetic intensity increases</strong>, and the point moves <strong>to the right</strong> on the plot.</p>
<hr>
</section>
<section id="increase-computational-performance-move-up" class="level4">
<h4 class="anchored" data-anchor-id="increase-computational-performance-move-up">2. Increase computational performance (move up)</h4>
<p>Alternatively, we can try to <strong>execute more operations per second</strong>, increasing <strong>op/s</strong>, which moves the point <strong>vertically upward</strong>.</p>
<ul>
<li>This corresponds to moving from the blue point <strong>(1, 1)</strong> to the green point <strong>(1, 2)</strong>.</li>
</ul>
<p>How can we increase op/s without changing the amount of data fetched?</p>
<p>This is typically achieved through <strong>instruction-level parallelism</strong>.</p>
<ul>
<li><strong>Vectorization</strong> is a classic example. Instead of performing a single scalar operation on narrow data, we operate on wider vectors, allowing multiple operations to be executed simultaneously.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/paste-6.png" class="img-fluid figure-img" width="370"></p>
<figcaption>Vectorizing the operation means more data is processed by a single operation</figcaption>
</figure>
</div>
<ul>
<li>On GPUs, another example is <strong>reducing warp divergence</strong>. If only half the threads in a warp are active, the hardware effectively wastes cycles. By restructuring the code so that all threads in a warp follow the same execution path (e.g., via warp specialization), we improve utilization of the processing units.</li>
</ul>
<p>These techniques increase <strong>throughput (op/s)</strong> and move the point <strong>upward</strong> on the plot.</p>
<p>What prevents us from moving upward indefinitely along the vertical axis?</p>
</section>
</section>
</section>
<section id="the-rooflines" class="level2">
<h2 class="anchored" data-anchor-id="the-rooflines">The Rooflines</h2>
<section id="memory-roof" class="level3">
<h3 class="anchored" data-anchor-id="memory-roof">Memory Roof</h3>
<p>Let us now look at the <strong>memory bandwidth</strong> required by each point on the plot.<br>
Bandwidth describes how fast data must move from memory to sustain a given implementation.</p>
<p>We can compute the required bandwidth from the slope of the line connecting the point to the origin:</p>
<p><span class="math display">\[
\text{BW} = \frac{y}{x} = \frac{\text{op/s}}{\text{op/byte}} = \text{byte/s}.
\]</span></p>
<blockquote class="blockquote">
<p>This is because each point represents a specific pairing of arithmetic intensity and performance. For the blue point, executing 1 op/s at an arithmetic intensity of 1 op/byte implies that the memory system must supply data at 1 byte/s, i.e., the required bandwidth is 1 byte/s.</p>
</blockquote>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/paste-16.png" class="img-fluid figure-img" width="420"></p>
<figcaption>Dividing the y value by x for each point gives us the required bandwidth we need for that implementation (point)</figcaption>
</figure>
</div>
<ul>
<li><p><strong>Blue point (1, 1):</strong><br>
BW = 1 / 1 = <strong>1 byte/s</strong></p></li>
<li><p><strong>Red point (2, 1):</strong><br>
BW = 1 / 2 = <strong>0.5 byte/s</strong></p></li>
<li><p><strong>Green point (1, 2):</strong><br>
BW = 2 / 1 = <strong>2 byte/s</strong></p></li>
</ul>
<p>We can see that the green point requires the highest bandwidth, followed by blue, then red:</p>
<div style="text-align: center">
<p><strong>Green &gt; Blue &gt; Red</strong> (ordered by slope)</p>
</div>
<p>This means the green implementation is the most <strong>memory-intensive</strong>. In other words, to sustain that level of performance, the system must be able to deliver a very high memory bandwidth.</p>
<p>Now suppose the system’s <strong>peak memory bandwidth</strong> is only <strong>1.5 byte/s</strong>. In that case, the green implementation is no longer feasible. The memory subsystem simply cannot supply data fast enough.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/paste-17.png" class="img-fluid figure-img" width="518"></p>
<figcaption>For an implementation, bandwidth must be lower than the system capacity</figcaption>
</figure>
</div>
<p>At this point, we hit a wall. Or more precisely, a <strong>roof</strong>.</p>
<p>This slanted line is called the <strong>memory bandwidth roof</strong>. It tells us that performance cannot increase indefinitely through techniques such as vectorization or parallelism: eventually, the implementation will be limited by how fast memory can deliver data.</p>
<hr>
</section>
<section id="compute-roof" class="level3">
<h3 class="anchored" data-anchor-id="compute-roof">Compute Roof</h3>
<p>So far, this suggests that we may not be fully utilizing the data we already have. Suppose we improve arithmetic intensity (move right, toward the red point) and then try to increase performance by moving upward.</p>
<p>What stops us now?</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/paste-21.png" class="img-fluid figure-img" width="516"></p>
<figcaption>For an implementation, computed performance (op/s) must also be lower than the system capacity</figcaption>
</figure>
</div>
<p>Consider an orange point at <strong>(2, 2)</strong>.</p>
<ul>
<li>Required bandwidth = 2 / 2 = <strong>1 byte/s</strong>, which is below the system’s peak bandwidth (1.5 byte/s).</li>
</ul>
<p>So memory is no longer the bottleneck. However, the processor itself has a maximum rate at which it can execute operations - its <strong>peak computational performance</strong>.</p>
<p>If the processor’s peak performance is <strong>1.5 op/s</strong>, then even with sufficient data, it cannot execute operations faster than that. Any point that lies on or above this horizontal limit is therefore <strong>compute-bound</strong>.</p>
<p>This horizontal line is called the <strong>compute roof</strong>.</p>
<hr>
</section>
<section id="the-roof-equation" class="level3">
<h3 class="anchored" data-anchor-id="the-roof-equation">The Roof Equation</h3>
<p>We can summarize the entire Roofline model with a single equation:</p>
<p><span class="math display">\[
\text{Performance} = \min\left( BW_{\text{peak}} \times AI, \text{Performance}_{\text{peak}} \right)
\]</span></p>
<p>This equation defines the achievable performance (y) for every possible value of arithmetic intensity (x).</p>
<ul>
<li>The <strong>memory-bound region</strong> corresponds to the simple line equation <span class="math inline">\(y = \text{slope} \times x\)</span><br>
<span class="math display">\[
\text{Performance} = BW_{\text{peak}} \times AI
\]</span> where the slope is the system’s peak memory bandwidth.</li>
<li>The <strong>compute-bound region</strong> is limited by<br>
<span class="math display">\[
\text{Performance} = \text{Performance}_{\text{peak}}
\]</span> which already has the correct unit of op/s.</li>
</ul>
<p>Together, these two limits form the characteristic “roofline” shape.</p>
</section>
</section>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">Summary</h2>
<p>Let’s recap the whole idea and devise a solid strategy. Given an implementation (blue dot) our goal is to move it as right (higher arithmetic intensity = more FLOPs per byte transferred) and up (higher achieved FLOP/s = better utilization of the compute units) as possible.</p>
<p><img src="images/paste-19.png" class="img-fluid" alt="The goal is to move the point as far right-up as possible" width="462"></p>
<section id="going-right-higher-arithmetic-intensity-lower-bytes-per-op" class="level3">
<h3 class="anchored" data-anchor-id="going-right-higher-arithmetic-intensity-lower-bytes-per-op">Going Right (higher arithmetic intensity, lower bytes per OP)</h3>
<p>These focus on reducing memory traffic relative to computation (more reuse, less movement):</p>
<ol type="1">
<li><strong>Tiling / Blocking</strong> (cache blocking, shared memory tiling on GPU, register blocking)</li>
<li><strong>Kernel / Operator Fusion</strong> (fewer intermediate arrays → drastically less memory traffic)</li>
<li><strong>Better data layout</strong> (AoS → SoA, structure-of-arrays, padding for alignment, transpose tricks)</li>
<li><strong>Exploit Cache Locality</strong> (contiguous access, temporal locality → data reuse soon after loading, spatial locality)</li>
<li><strong>Loop fusion or fission</strong> (strategic — fuse when it increases reuse, fission when it enables better tiling/vectorization)</li>
<li><strong>Prefetching + cache blocking together</strong> (move data into faster levels before needed)</li>
<li><strong>In-place algorithms</strong> (avoid extra read/write of temporary buffers)</li>
<li><strong>Algorithmic or mathematical reformulation</strong> (higher-order methods, winograd-style conv, Strassen-like matmul, etc. — trade some extra flops for far less data movement)</li>
<li><strong>Quantization or lower precision</strong> (when acceptable — fewer bytes per value → higher effective intensity)</li>
<li><strong>Sparsity exploitation</strong> (structured/unstructured sparsity, pruning + sparse formats → skip loading/storing zeros)</li>
<li><strong>Data compression or lossless compression</strong> in memory (sometimes used in scientific codes)</li>
</ol>
</section>
<section id="going-up-higher-ops-better-compute-utilization" class="level3">
<h3 class="anchored" data-anchor-id="going-up-higher-ops-better-compute-utilization">Going up (higher OP/s, better compute utilization)</h3>
<p>These techniques primarily improve how efficiently the processor/GPU uses its floating-point units, vector lanes, tensor cores, etc.:</p>
<ol type="1">
<li><strong>SIMD/Vectorization</strong> (use wider vectors: AVX, AVX-512, NEON, CUDA warps with vector types)</li>
<li><strong>Loop Unrolling</strong> (reduce loop overhead, expose more independent operations)</li>
<li><strong>Kernel/Operator Fusion</strong> (e.g.&nbsp;Fused Multiply-Add → FMA, fused conv+bn+relu, elementwise + reduction chains)</li>
<li><strong>Warp Specialization</strong> (GPU) / <strong>Thread divergence minimization</strong></li>
<li><strong>Prefetching</strong> (software prefetch or hardware auto-prefetch tuning — hides latency → higher issue rate)</li>
<li><strong>Better instruction mix / throughput-bound fixes</strong> (reduce divides → use reciprocals, minimize expensive math functions)</li>
<li><strong>Multi-threading/Occupancy</strong> (more concurrent warps/threads to hide latency and saturate functional units)</li>
<li><strong>Use of specialized units</strong> (tensor cores, DP4A/INT8/FP16/bfloat16 paths, AMX on x86, etc.)</li>
<li><strong>Reduce thread predication/control divergence</strong> (branchless code, mask-based ops)</li>
<li><strong>Instruction-level parallelism (ILP)</strong> within a thread (reorder code, expose more independent ops)</li>
</ol>
</section>
<section id="dual-impact-techniques-move-both-right-and-up" class="level3">
<h3 class="anchored" data-anchor-id="dual-impact-techniques-move-both-right-and-up">Dual-impact techniques (move both right <strong>and</strong> up)</h3>
<p>These are especially powerful because they simultaneously reduce memory pressure <strong>and</strong> improve compute efficiency:</p>
<ol type="1">
<li><strong>Kernel Fusion</strong> / <strong>Operator fusion</strong> (very high impact on both axes)</li>
<li><strong>Tiling + Vectorization</strong> together (typical combination in high-performance codes)</li>
<li><strong>FMA usage</strong> (often enabled by fusion or careful coding)</li>
<li><strong>Shared memory + warp-level tiling</strong> (GPU classic)</li>
<li><strong>Register blocking + unrolling</strong> (CPU classic)</li>
</ol>
<blockquote class="blockquote">
<p>A good mental model is: first get the point right of the ridge point (out of the green marked memory-bound regime), then push up toward the flat compute roof. Many real optimizations alternate between these two goals as we iterate.</p>
</blockquote>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>