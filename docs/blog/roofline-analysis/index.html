<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Md Saidul Hoque Anik">
<meta name="description" content="A gentle introduction to roofline model">

<title>Understanding the roofline model without the roof! – Md Saidul Hoque Anik</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-b758ccaa5987ceb1b75504551e579abf.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" class="quarto-color-scheme-extra" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-69585d0cb7eb4d91e1e9639bd63741e7.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark-435edb4a015d21cda02749244a61383a.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<link href="../../site_libs/bootstrap/bootstrap-69585d0cb7eb4d91e1e9639bd63741e7.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme-extra" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<link href="https://cdn.jsdelivr.net/npm/charter-webfont@4.1.0/charter.min.css" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400..700;1,400..700&amp;family=Merriweather:ital,opsz,wght@0,18..144,300..900;1,18..144,300..900&amp;family=Open+Sans:ital,wght@0,300..800;1,300..800&amp;display=swap" rel="stylesheet">
<link href="https://fonts.cdnfonts.com/css/palatino" rel="stylesheet">
<script src="../../script.js"></script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light"><script id="quarto-html-before-body" type="application/javascript">
    const toggleBodyColorMode = (bsSheetEl) => {
      const mode = bsSheetEl.getAttribute("data-mode");
      const bodyEl = window.document.querySelector("body");
      if (mode === "dark") {
        bodyEl.classList.add("quarto-dark");
        bodyEl.classList.remove("quarto-light");
      } else {
        bodyEl.classList.add("quarto-light");
        bodyEl.classList.remove("quarto-dark");
      }
    }
    const toggleBodyColorPrimary = () => {
      const bsSheetEl = window.document.querySelector("link#quarto-bootstrap:not([rel=disabled-stylesheet])");
      if (bsSheetEl) {
        toggleBodyColorMode(bsSheetEl);
      }
    }
    const setColorSchemeToggle = (alternate) => {
      const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
      for (let i=0; i < toggles.length; i++) {
        const toggle = toggles[i];
        if (toggle) {
          if (alternate) {
            toggle.classList.add("alternate");
          } else {
            toggle.classList.remove("alternate");
          }
        }
      }
    };
    const toggleColorMode = (alternate) => {
      // Switch the stylesheets
      const primaryStylesheets = window.document.querySelectorAll('link.quarto-color-scheme:not(.quarto-color-alternate)');
      const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
      manageTransitions('#quarto-margin-sidebar .nav-link', false);
      if (alternate) {
        // note: dark is layered on light, we don't disable primary!
        enableStylesheet(alternateStylesheets);
        for (const sheetNode of alternateStylesheets) {
          if (sheetNode.id === "quarto-bootstrap") {
            toggleBodyColorMode(sheetNode);
          }
        }
      } else {
        disableStylesheet(alternateStylesheets);
        enableStylesheet(primaryStylesheets)
        toggleBodyColorPrimary();
      }
      manageTransitions('#quarto-margin-sidebar .nav-link', true);
      // Switch the toggles
      setColorSchemeToggle(alternate)
      // Hack to workaround the fact that safari doesn't
      // properly recolor the scrollbar when toggling (#1455)
      if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
        manageTransitions("body", false);
        window.scrollTo(0, 1);
        setTimeout(() => {
          window.scrollTo(0, 0);
          manageTransitions("body", true);
        }, 40);
      }
    }
    const disableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        stylesheet.rel = 'disabled-stylesheet';
      }
    }
    const enableStylesheet = (stylesheets) => {
      for (let i=0; i < stylesheets.length; i++) {
        const stylesheet = stylesheets[i];
        if(stylesheet.rel !== 'stylesheet') { // for Chrome, which will still FOUC without this check
          stylesheet.rel = 'stylesheet';
        }
      }
    }
    const manageTransitions = (selector, allowTransitions) => {
      const els = window.document.querySelectorAll(selector);
      for (let i=0; i < els.length; i++) {
        const el = els[i];
        if (allowTransitions) {
          el.classList.remove('notransition');
        } else {
          el.classList.add('notransition');
        }
      }
    }
    const isFileUrl = () => {
      return window.location.protocol === 'file:';
    }
    const hasAlternateSentinel = () => {
      let styleSentinel = getColorSchemeSentinel();
      if (styleSentinel !== null) {
        return styleSentinel === "alternate";
      } else {
        return false;
      }
    }
    const setStyleSentinel = (alternate) => {
      const value = alternate ? "alternate" : "default";
      if (!isFileUrl()) {
        window.localStorage.setItem("quarto-color-scheme", value);
      } else {
        localAlternateSentinel = value;
      }
    }
    const getColorSchemeSentinel = () => {
      if (!isFileUrl()) {
        const storageValue = window.localStorage.getItem("quarto-color-scheme");
        return storageValue != null ? storageValue : localAlternateSentinel;
      } else {
        return localAlternateSentinel;
      }
    }
    const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
      const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
      const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
      let newTheme = '';
      if(authorPrefersDark) {
        newTheme = isAlternate ? baseTheme : alternateTheme;
      } else {
        newTheme = isAlternate ? alternateTheme : baseTheme;
      }
      const changeGiscusTheme = () => {
        // From: https://github.com/giscus/giscus/issues/336
        const sendMessage = (message) => {
          const iframe = document.querySelector('iframe.giscus-frame');
          if (!iframe) return;
          iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
        }
        sendMessage({
          setConfig: {
            theme: newTheme
          }
        });
      }
      const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
      if (isGiscussLoaded) {
        changeGiscusTheme();
      }
    };
    const authorPrefersDark = false;
    const darkModeDefault = authorPrefersDark;
      document.querySelector('link#quarto-text-highlighting-styles.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
      document.querySelector('link#quarto-bootstrap.quarto-color-scheme-extra').rel = 'disabled-stylesheet';
    let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
    // Dark / light mode switch
    window.quartoToggleColorScheme = () => {
      // Read the current dark / light value
      let toAlternate = !hasAlternateSentinel();
      toggleColorMode(toAlternate);
      setStyleSentinel(toAlternate);
      toggleGiscusIfUsed(toAlternate, darkModeDefault);
      window.dispatchEvent(new Event('resize'));
    };
    // Switch to dark mode if need be
    if (hasAlternateSentinel()) {
      toggleColorMode(true);
    } else {
      toggleColorMode(false);
    }
  </script>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Md Saidul Hoque Anik</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../research"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../news"> 
<span class="menu-text">News</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../teaching"> 
<span class="menu-text">Teaching</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-more" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">More</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-more">    
        <li>
    <a class="dropdown-item" href="../../leetgpu">
 <span class="dropdown-text">LeetGPU</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../leadership/">
 <span class="dropdown-text">Leadership</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../software">
 <span class="dropdown-text">Software</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../news/#category=Publication">
 <span class="dropdown-text">Publications</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../blog">
 <span class="dropdown-text">Blog</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#preface" id="toc-preface" class="nav-link active" data-scroll-target="#preface">Preface</a></li>
  <li><a href="#the-plot" id="toc-the-plot" class="nav-link" data-scroll-target="#the-plot">The Plot</a>
  <ul class="collapse">
  <li><a href="#improvement-strategies" id="toc-improvement-strategies" class="nav-link" data-scroll-target="#improvement-strategies">Improvement Strategies</a></li>
  </ul></li>
  <li><a href="#the-rooflines" id="toc-the-rooflines" class="nav-link" data-scroll-target="#the-rooflines">The Rooflines</a>
  <ul class="collapse">
  <li><a href="#memory-roof" id="toc-memory-roof" class="nav-link" data-scroll-target="#memory-roof">Memory Roof</a></li>
  <li><a href="#compute-roof" id="toc-compute-roof" class="nav-link" data-scroll-target="#compute-roof">Compute Roof</a></li>
  <li><a href="#the-roof-equation" id="toc-the-roof-equation" class="nav-link" data-scroll-target="#the-roof-equation">The Roof Equation</a></li>
  </ul></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">Summary</a>
  <ul class="collapse">
  <li><a href="#going-up-higher-ops-better-compute-utilization" id="toc-going-up-higher-ops-better-compute-utilization" class="nav-link" data-scroll-target="#going-up-higher-ops-better-compute-utilization">Going up (higher OP/s, better compute utilization)</a></li>
  <li><a href="#going-right-higher-arithmetic-intensity-lower-bytes-per-op" id="toc-going-right-higher-arithmetic-intensity-lower-bytes-per-op" class="nav-link" data-scroll-target="#going-right-higher-arithmetic-intensity-lower-bytes-per-op">Going Right (higher arithmetic intensity, lower bytes per OP)</a></li>
  <li><a href="#dual-impact-techniques-move-both-right-and-up" id="toc-dual-impact-techniques-move-both-right-and-up" class="nav-link" data-scroll-target="#dual-impact-techniques-move-both-right-and-up">Dual-impact techniques (move both right <strong>and</strong> up)</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">


<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Understanding the roofline model without the roof!</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Hands-on</div>
  </div>
  </div>

<div>
  <div class="description">
    A gentle introduction to roofline model
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Md Saidul Hoque Anik </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 2026</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="preface" class="level2">
<h2 class="anchored" data-anchor-id="preface">Preface</h2>
<p>Any computing system consists of memory and a processor, like the diagram below. During a program execution, we fetch some data from the memory into the processor, and perform operations in it.</p>
<p>The speed at which data can be transferred through the bus can be denoted using the unit: Byte/s. <strong>This is a property of the memory unit.</strong></p>
<p>The speed at which a processor can execute the ops can be denoted using unit: op/s. <strong>This is a property of the processor (CPU/GPU).</strong></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/paste-20.png" class="img-fluid figure-img" width="468"></p>
<figcaption>A typical computing system</figcaption>
</figure>
</div>
<p>An example of a program would be a vector addition. We bring two float element from memory, add them (the actual op), and store them back into another memory location. <u>Let’s omit the store for now</u>, since storing may not use the bandwidth immediately (may be stored in cache for later write).</p>
<p>This means we take two float (4 + 4 = 8 bytes), and perform a single op in it.</p>
<p>We say that this program has an <strong>arithmetic intensity</strong> (AI) of 1 op per 8 byte = 1/8 op/byte. Per 1 byte it fetches, it does 1/8 operations. This performance metric measures how well the program is utilizing the data it fetches. <strong>This is the property of the program/implementation.</strong></p>
<p>Another type of performance metric is how fast the CPU/GPU is executing these ops: Op/s. We call this computational performance (or sometimes throughput).</p>
<blockquote class="blockquote">
<p>AI = op/byte; how many operations we are getting out of a byte; also called <strong>Operational Intensity</strong> <strong>(OI)</strong> sometimes</p>
<p>Performance = op/s; tells you how fast your processor is crunching these operations; also called throughput</p>
<p><strong>Note: op is typically called FLOP since we mostly care about floating points operations. But we will keep it simple and call it op throughout the article.</strong></p>
</blockquote>
</section>
<section id="the-plot" class="level2">
<h2 class="anchored" data-anchor-id="the-plot">The Plot</h2>
<p>Let’s plot them in a X-Y axis. X is op/byte - how well we are utilizing a byte we are getting. Y is op/s - how fast are we running these ops.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/paste-14.png" class="img-fluid figure-img" width="512"></p>
<figcaption>The Roofline plot without the roofs!</figcaption>
</figure>
</div>
<p>As we go right, we gain more performance by better utilizing the data we have in hand.</p>
<p>As we go up, we gain more performance by squeezing more operations into each cycle (second).</p>
<p>In many cases, we actually move diagonally (up-right) since the improvement impacts both axis.</p>
<section id="improvement-strategies" class="level3">
<h3 class="anchored" data-anchor-id="improvement-strategies">Improvement Strategies</h3>
<p>Let’s consider a single points on this plot first. The blue point (1, 1).</p>
<p>This tells us, our implementation is executing 1 op per byte it receives (x coordinate). And it is executing speed is 1 op/s (the y coordinate).</p>
<p>This information by itself doesn’t say much about how good the implementation is. But following the theme of this article (memory or processor), we can do two things to gain more performance.</p>
<ul>
<li><p>Either we can try to better utilize the bytes we have in hand. I.e. we can increase the amount of ops we can do per byte (try to move right horizontally).</p>
<ul>
<li><p>That’s going from blue (1, 1) point to red (2, 1) point looks like. How can we do more work per byte?</p></li>
<li><p>An example would be a matmul operation where the B matrix is also in row major order. Since we need to access elements across the columns, during each load the system will bring a cache, use only one element from it, and throw the rest away.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/paste-15.png" class="img-fluid figure-img" width="629"></p>
<figcaption>Accessing an element of each row means we will invalidate cache line every single time</figcaption>
</figure>
</div></li>
<li><p>Instead, if we use the transposed B matrix, this will result in better cache utilization. Meaning that we are doing more work with the available bytes. This implementation will increase AI, depicting the point moving right horizontally (blue to red point).</p></li>
</ul></li>
<li><p>Or, we can try to increase the number of ops per sec.</p>
<ul>
<li><p>That’s going from blue (1, 1) point to green point (1, 2).</p></li>
<li><p>How do we increase ops/s in an implementation given the same byte fetched? I.e. how do we improve performance (or throughput)? Using some sort of instruction level parallelism.</p>
<ul>
<li><p>An example could be vectorizing. Instead of 1 op consuming scalar bytes, we let it consume wider bytes.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/paste-6.png" class="img-fluid figure-img" width="370"></p>
<figcaption>Vectorizing the operation means more data is processed by a single operation</figcaption>
</figure>
</div></li>
<li><p>Another example is to reduce warp divergence in GPU. If half of the warp is idle, then essentially it is taking twice the amount cycle to process the same amount of data. If we rewrite the code so that each warp is doing the same thing (e.g.: wrap specialization), the implementation becomes more efficient in terms of performance (ops/s) - thus moves upwards vertically.</p></li>
</ul></li>
</ul></li>
</ul>
<p>What prevents us from moving upward vertically by indefinite amount?</p>
</section>
</section>
<section id="the-rooflines" class="level2">
<h2 class="anchored" data-anchor-id="the-rooflines">The Rooflines</h2>
<section id="memory-roof" class="level3">
<h3 class="anchored" data-anchor-id="memory-roof">Memory Roof</h3>
<p>Let’s look at the bandwidth we will need for each of the points. The bandwidth means how fast memory needs to move in order to accommodate that implementation. We can compute the bandwidth by computing the slope, <span class="math inline">\(y \div x = ops/s \div ops/byte = byte/s\)</span>.</p>
<p><img src="images/paste-16.png" class="img-fluid" alt="Dividing the y value by x for each point gives us the required bandwidth we need for that implementation" width="420"></p>
<ul>
<li><p>For the blue point (1,1): BW = 1/1 = 1 byte/s</p></li>
<li><p>For the red point (2,1): BW = 1/2 = 0.5 byte/s</p></li>
<li><p>For the green point (1, 2): BW = 2/1 = 2 byte/s</p></li>
</ul>
<p>We say the green point is more memory intensive than blue and red. The order of memory intensity is green &gt; blue &gt; red (given by the slopes).</p>
<p>This means, the green implementation is more <strong>memory-bound</strong>. i.e.&nbsp;in order to keep that performance, we need to have that high bandwidth in that system.</p>
<p>What if we don’t have that much BW in the system? If the max BW is 1.5B/s? This means that implementation (green dot) is not supported by that system.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/paste-17.png" class="img-fluid figure-img" width="518"></p>
<figcaption>For an implementation, bandwidth must be lower than the system capacity</figcaption>
</figure>
</div>
<p>We hit a wall! A roof to be specific. A slanted roof. The memory bandwidth roof. This roof tells us that our implementation cannot arbitrarily improve performance by vectorization and eventually hit a point where it will simply not be able to receive enough bytes to process.</p>
</section>
<section id="compute-roof" class="level3">
<h3 class="anchored" data-anchor-id="compute-roof">Compute Roof</h3>
<p>Okay great! That means we are probably not using up the bytes we have at hand. Lets go right (red point) and try to go up. We adjust our implementation so that it now requires less memory and do more work with it. In that case what might be preventing us to go up?</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/paste-18.png" class="img-fluid figure-img" width="516"></p>
<figcaption>For an implementation, computed performance (op/s) must also be lower than the system capacity</figcaption>
</figure>
</div>
<p>Let’s imagine an orange dot (2, 2). The BW is 2/2 = 1 bytes/s which is below the peak BW of the system (1.5 bytes/s). However, the processor itself also has its max capacity - the highest op it can crank per second - the peak performance.</p>
<p>If the peak performance is 1.5 Ops/s, this means even we have the right amount of data, we cannot process it faster than 1.5 ops/s. This makes any point on the horizontal line (peak perf line) compute bound. This line is called the <strong>compute roof</strong>.</p>
</section>
<section id="the-roof-equation" class="level3">
<h3 class="anchored" data-anchor-id="the-roof-equation">The Roof Equation</h3>
<p>Let’s end the discussion with the equation of the roof.</p>
<p><span class="math display">\[
Performance = min(BW_{peak} \times AI, Performance_{peak})
\]</span></p>
<p>This equation generates <span class="math inline">\(y\)</span> for every possible value of AI (<span class="math inline">\(x\)</span>).</p>
<ul>
<li><p>The first part is where the operation is memory bound. For this, the equation is <span class="math inline">\(y = slope \times x\)</span> where y = Performance, x = AI, and slope is max possible BW (<span class="math inline">\(BW_{peak}\)</span>).</p></li>
<li><p>The second part, the compute bound roof is straightforward, <span class="math inline">\(Performance_{peak}\)</span>. It already has the right unit (op/s).</p></li>
</ul>
</section>
</section>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">Summary</h2>
<p>Let’s recap the whole idea and devise a solid strategy. Given an implementation (blue dot) our goal is to move it as right (higher arithmetic intensity = more FLOPs per byte transferred) and up (higher achieved FLOP/s = better utilization of the compute units) as possible.</p>
<p><img src="images/paste-19.png" class="img-fluid" alt="The goal is to move the point as far right-up as possible" width="462"></p>
<section id="going-up-higher-ops-better-compute-utilization" class="level3">
<h3 class="anchored" data-anchor-id="going-up-higher-ops-better-compute-utilization">Going up (higher OP/s, better compute utilization)</h3>
<p>These techniques primarily improve how efficiently the processor/GPU uses its floating-point units, vector lanes, tensor cores, etc.:</p>
<ol type="1">
<li><strong>SIMD/Vectorization</strong> (use wider vectors: AVX, AVX-512, NEON, CUDA warps with vector types)</li>
<li><strong>Loop Unrolling</strong> (reduce loop overhead, expose more independent operations)</li>
<li><strong>Kernel/Operator Fusion</strong> (e.g.&nbsp;Fused Multiply-Add → FMA, fused conv+bn+relu, elementwise + reduction chains)</li>
<li><strong>Warp Specialization</strong> (GPU) / <strong>Thread divergence minimization</strong></li>
<li><strong>Prefetching</strong> (software prefetch or hardware auto-prefetch tuning — hides latency → higher issue rate)</li>
<li><strong>Better instruction mix / throughput-bound fixes</strong> (reduce divides → use reciprocals, minimize expensive math functions)</li>
<li><strong>Multi-threading/Occupancy</strong> (more concurrent warps/threads to hide latency and saturate functional units)</li>
<li><strong>Use of specialized units</strong> (tensor cores, DP4A/INT8/FP16/bfloat16 paths, AMX on x86, etc.)</li>
<li><strong>Reduce thread predication/control divergence</strong> (branchless code, mask-based ops)</li>
<li><strong>Instruction-level parallelism (ILP)</strong> within a thread (reorder code, expose more independent ops)</li>
</ol>
</section>
<section id="going-right-higher-arithmetic-intensity-lower-bytes-per-op" class="level3">
<h3 class="anchored" data-anchor-id="going-right-higher-arithmetic-intensity-lower-bytes-per-op">Going Right (higher arithmetic intensity, lower bytes per OP)</h3>
<p>These focus on reducing memory traffic relative to computation (more reuse, less movement):</p>
<ol type="1">
<li><strong>Tiling / Blocking</strong> (cache blocking, shared memory tiling on GPU, register blocking)</li>
<li><strong>Kernel / Operator Fusion</strong> (fewer intermediate arrays → drastically less memory traffic)</li>
<li><strong>Better data layout</strong> (AoS → SoA, structure-of-arrays, padding for alignment, transpose tricks)</li>
<li><strong>Exploit Cache Locality</strong> (contiguous access, temporal locality → data reuse soon after loading, spatial locality)</li>
<li><strong>Loop fusion or fission</strong> (strategic — fuse when it increases reuse, fission when it enables better tiling/vectorization)</li>
<li><strong>Prefetching + cache blocking together</strong> (move data into faster levels before needed)</li>
<li><strong>In-place algorithms</strong> (avoid extra read/write of temporary buffers)</li>
<li><strong>Algorithmic or mathematical reformulation</strong> (higher-order methods, winograd-style conv, Strassen-like matmul, etc. — trade some extra flops for far less data movement)</li>
<li><strong>Quantization or lower precision</strong> (when acceptable — fewer bytes per value → higher effective intensity)</li>
<li><strong>Sparsity exploitation</strong> (structured/unstructured sparsity, pruning + sparse formats → skip loading/storing zeros)</li>
<li><strong>Data compression or lossless compression</strong> in memory (sometimes used in scientific codes)</li>
</ol>
</section>
<section id="dual-impact-techniques-move-both-right-and-up" class="level3">
<h3 class="anchored" data-anchor-id="dual-impact-techniques-move-both-right-and-up">Dual-impact techniques (move both right <strong>and</strong> up)</h3>
<p>These are especially powerful because they simultaneously reduce memory pressure <strong>and</strong> improve compute efficiency:</p>
<ol type="1">
<li><strong>Kernel Fusion</strong> / <strong>Operator fusion</strong> (very high impact on both axes)</li>
<li><strong>Tiling + Vectorization</strong> together (typical combination in high-performance codes)</li>
<li><strong>FMA usage</strong> (often enabled by fusion or careful coding)</li>
<li><strong>Shared memory + warp-level tiling</strong> (GPU classic)</li>
<li><strong>Register blocking + unrolling</strong> (CPU classic)</li>
</ol>
<blockquote class="blockquote">
<p>A good mental model is: first get the point right of the ridge point (out of the memory-bound regime), then push up toward the flat compute roof. Many real optimizations alternate between these two goals as you iterate.</p>
</blockquote>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    // Ensure there is a toggle, if there isn't float one in the top right
    if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
      const a = window.document.createElement('a');
      a.classList.add('top-right');
      a.classList.add('quarto-color-scheme-toggle');
      a.href = "";
      a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
      const i = window.document.createElement("i");
      i.classList.add('bi');
      a.appendChild(i);
      window.document.body.appendChild(a);
    }
    setColorSchemeToggle(hasAlternateSentinel())
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>